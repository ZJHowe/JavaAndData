# 进程同步与互斥、信号量机制、管程

## 一、进程同步、进程互斥的概念
### 1.1 进程同步
&emsp;&emsp;由于进程具有**异步性**，也就是说各个并发的进程以各个独立且不可预知的速度向前推进。当我们需要进程按照某种特定的顺序执行时（例如之前所说的管道通信，向管道写数据和从管道读数据的进程是并发执行的，但我们必须保证写数据先执行，读数据进程等待写数据进程完成后再执行），需要依靠操作系统提供的**进程同步机制**来完成。
### 1.2 进程互斥
&emsp;&emsp;进程的并发需要共享的支持（并发的进程可能需要共享一些系统资源）。资源共享分为**互斥共享方式**和**同时共享方式**。
&emsp;&emsp;我们将==一个时间段内只允许一个进程使用的资源称为**临界资源**==（如物理设备，部分变量、数据、内存缓冲区等）。对临界资源的访问，必须**互斥**进行（即一个进程访问临界资源时，另一个进程想要访问临界必须要等待）。
&emsp;&emsp;对临界资源的访问宏观上分为以下步骤：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210227134324440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODgzNjI3Mw==,size_16,color_FFFFFF,t_70#pic_center)&emsp;&emsp;对临界资源的互斥访问需要遵循以下**原则**：

 1. **空闲让进**：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。
 2. **忙则等待**：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。
 3. **有限等待**：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）。
 4. **让权等待**：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。

## 二、进程互斥的实现方法
### 2.1 进程互斥的软件实现方法
 - 单标志法：设定一个turn标志(允许访问的进程号)，当一个进程在访问完临界区后会将使用临界区的权限转交给另一个进程（即每个进程进入临界区的权限只能被另一个进程赋予）。因此存在违背**空闲让进**原则的问题。
 - 双标志先检查法：设置一个布尔型数组flag[n]，数组中各个元素用来标记各个进程想要进入临界区的意愿。每个进程在进入临界区前都检查是否有其他进程想要进入临界区，没有的话就将自己对应的flag[i]修改为true，开始访问临界区。但在并发的情况下，由于进程切换原因，可能导致两个进程同时进入临界区，违背了**忙则等待**的原则（进入区检查和上锁不是原子操作）。
 - 双标志后检查法：与先检查法类似，只是将上锁提前到了检查前，这样可能导致多个线程都无法进入临界区。违背了**空闲让进**和**有限等待**原则
 - **Peterson算法**：
 &emsp;&emsp;Peterson算法的关键思想是，让进程争抢进入临界区的问题转换成进程主动让其他进程先使用的问题。同样定义了布尔数组来表示进入意愿，也定义了turn标志表示优先让哪个进程进入。达到了多个进程都有进入临界区的意愿时，进程间的“孔融让梨”的效果。但仍然没有遵循**让权等待**的原则。
![Peterson算法思想](https://img-blog.csdnimg.cn/20210227141411472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODgzNjI3Mw==,size_16,color_FFFFFF,t_70#pic_center)
### 2.2 进程互斥的硬件实现方法
 - 中断屏蔽方法：之前所提到的在内核态下使用**开/关中断指令**实现进程互斥访问临界区。问题在于不适用于多处理机，并且只适用于操作系统内核进程。
 - TestAndSet(TS指令或TSL指令)：定义了一个布尔型的**共享变量lock**来表示当前临界区是否被加锁。下面是实现的原理讲解（不是真的实现过程，TestAndSet是硬件实现的）：
![TestAndSet](https://img-blog.csdnimg.cn/2021022714351473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODgzNjI3Mw==,size_16,color_FFFFFF,t_70#pic_center)
缺点仍然是不满足**让权等待**原则，无法进入临界区的进程占用处理机执行TSL指令。
 - Swap指令：类似TSL指令，同操作硬件，只是实现方式不一样，且同不满足**让权等待**原则。
## 三、信号量机制*
### 3.1 信号量机制的概念
 &emsp;&emsp;**信号量本质是一个变量**（整数或者更复杂的记录型变量），信号量一般用来**表示系统中某种资源的数量**。用户进程使用操作系统提供的（**wait和signal原语，P、V操作**）来对信号量进行操作，从而实现进程互斥和同步。
 - 整型信号量：用一个整数型变量作为信号量，用于表示系统中某种资源的数量。与软件实现中的双标志先检查法类似，只是信号量是通过原语进程实现的，是原子操作。但还是无法解决**让权等待**的问题
 - **记录型信号量**：增加了一个**等待队列**，使得无法获取资源的线程能够被阻塞，等待资源充足后被唤醒，来解决**让权等待**问题。
![记录型信号量](https://img-blog.csdnimg.cn/20210227152310622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODgzNjI3Mw==,size_16,color_FFFFFF,t_70#pic_center)
*注意：原语操作中先将信号量的值改变再判断。*
### 3.2 信号量机制实现进程互斥与同步
 &emsp;&emsp;临界区可以看作一种特殊的系统资源，用**互斥信号量mutex=1**来表示。在临界区前进行P(mutex)，在临界区后执行V(mutex)，来实现基于信号量的**进程互斥**。
  &emsp;&emsp;由于操作系统的异步性，进程是异步执行的。但有的时候我们就希望进程的执行有一定的顺序，也就是**线程同步问题**。具体实现是设置一个**同步信号量S=0**。若在某一线程执行到指定位置处先进行一个V(S)操作(此时S=1)，在另一进程需要同步的代码前执行一个P(S)操作，S变回0，且不执行block原语，而是执行接下来的代码；若某个线程先执行了P(S)操作，S=-1，没有可用资源，这个进程会阻塞自己，当其他进程执行到了V(S)后，S=0，代表有进程阻塞在阻塞队列中，会执行wakeup原语唤醒阻塞进程。**总结下就是，实现同步，前V后P**。
### 3.3 生产者与消费者问题
&emsp;&emsp;==问题描述：如何使用信号量实现的互斥、同步操作来实现生产者消费者模型？==
&emsp;&emsp;首先，为什么说要用信号量实现的互斥和同步呢？因为缓冲区是临界资源，各进程必须是**互斥**访问的；并且消费者消费数据必须在生产者生产数据后进行，缓冲区满后需要先消费再生产，是需要**同步**的。
![生产者消费者进程模型实现](https://img-blog.csdnimg.cn/2021022716313725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODgzNjI3Mw==,size_16,color_FFFFFF,t_70#pic_center)
*注意：由于P操作可能使得进程进入阻塞状态，实现互斥的P操作一定要放在实现同步的P操作后，否则会出现死锁！*

区别于进程同步，补充**线程同步**的方法：
&emsp;&emsp;线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：

 - 互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
 - 信号量(Semphares) ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
 - 事件(Event) :Wait/Notify，通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较。
## 四、管程（monitor）
### 4.1 管程的定义与基本特性
&emsp;&emsp;**管程**是一种特殊**软件模块**，有以下部分组成（类似于面向对象中的类）：
 - 局部于管程的**共享数据结构**
 - 对该数据结构进行的**一组过程**（方法）。
 - 对共享数据结构进行初始化
 - 管程的名字
&emsp;&emsp;**管程**的**基本特征**：
 - 局部于管程的数据只能被局部于管程的过程访问
 - 一个进程只有通过调用管程内的过程才能防问管程的共享数据
 - 每次仅允许一个进程在管程内执行某个内部过程

&emsp;&emsp;由上面的总结可以看到，编译语言去实现管程，是实现一个**数据私有方法公有且加锁**的一个类。==Java中synchronized的实现就是类似于管程的实现==。

------
参考：《王道考研操作系统》
地址：https://www.bilibili.com/video/BV1YE411D7nH
