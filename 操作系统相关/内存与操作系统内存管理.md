# 内存与操作系统内存管理

## 一、内存的基础知识
&emsp;&emsp;内存是用于存放数据的硬件，**程序执行前需要将数据放入内存中才能被CPU处理**。内存通过对内部的**存储单元编地址来解决并发执行下各个程序的数据区分**，根据计算机字长的不同，存储单元大小不同（如64位计算机每个字大小为64位，8个字节）。\
&emsp;&emsp;内存存放的**相对寻址**：编译语言编译后的指令寻址，是通过**相对地址**实现的，实际存入内存时再根据进程在内存中的起始地值得到**绝对地址**。编译生成的机器语言中的地址实际都是**逻辑地址**，在通过链接（形成完整逻辑地址）后，通过装入模块装入内存运行，这时将**逻辑地址转换成物理地址**（主要使用**动态重定位**装入方法：CPU内有重定位寄存器保存了程序存放内存的起始位置，结合逻辑地址可以实现动态重定位）。
## 二、内存管理
&emsp;&emsp;操作系统是系统资源的管理者，也需要对内存进行管理。操作系统需要负责以下事情：
> 1. 提供**某种技术从逻辑上对内存空间进行扩充**
> 2. **内存空间的分配与回收**
> 3. 提供地址转换功能，**负责程序从逻辑地址到物理地址的转换**（动态重定位，依赖于重定位寄存器）
> 4. 提供**内存保护**功能，保证各个进程在各自存储空间内运行，互不干扰。
### 2.1 内存空间扩充
&emsp;&emsp;操作系统对内存空间的扩充主要有覆盖技术、交换技术和虚拟存储技术（后面详细介绍）：
 > - 覆盖技术：用于早期操作系统中。
 > - 交换技术：实际就是进程调度中的**内存调度**，进程在内存和磁盘间动态调度（进程未结束前内存中始终保留PCB信息）。进程从内存中被换出是保存在磁盘的**对换区**中（这个区域I/O速度比文件区快，详细在文件部分讲解）。
### 2.2 内存空间的分配与回收**
&emsp;&emsp;内存空间分配分为连续分配管理方式和非连续分配管理方式：\
（1）==连续分配管理方式==中又分为单一连续分配、固定分区分配和**动态分区分配**。
- 单一连续分配，只适用于单任务操作系统。
- **固定分区分配**，将内存中除了系统区外的用户空间分为固定大小或大小不等的分区，并建立**分区说明表**的数据结构（数组或链表）记录每个分区大小、起始地址、状态等信息，缺点在于用户程序过大需要覆盖技术支持，且会产生内部碎片。
- **动态分区分配**，在进程装入内存时，动态地建立分区。操作系统使用**空闲分区表或空闲分区链**来记录内存使用情况（分区号、分区大小、起始地址等）。
![常用记录内存使用情况的数据结构](https://img-blog.csdnimg.cn/20210228172858117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODgzNjI3Mw==,size_16,color_FFFFFF,t_70#pic_center)
而当新的进程要装入内存时，需要用动态分区分配算法来选择出一个合适的分区。\
（2）==非连续分配管理方式==为用户进程分配的可以是一些分散的内存空间，主要管理方式有**分页存储管理**、**分段存储管理**和**段页式存储管理**：
- **分页存储管理**：将内存空间分为大小相等的小分区，每个分区称为**页框**，编号从0开始。相应地，将用户进程的地址空间也分为 ***与页框大小相等*** 的一个个区域，每个部分称为**页**，编号同样从0开始。（注：进程的最后一个页可能没有一个页框那么大，因此页框不能过大，否则可能产生过大的内部碎片）\
&emsp;&emsp;那么分页存储是离散存储的，如何实现逻辑地址到物理地址的转换？\
&emsp;&emsp;将**动态重定位**的思想使用到分页存储中，首先计算逻辑地址对应的页号，得到该页号在内存中存放的起始地址，计算逻辑地址在页内的“偏移量”，由此物理地址=页面地址+页内偏移量。而要知道进程的每个页在内存中存放的位置，操作系统需要为每个进程建立一张**页表**。
![分页基本地址变化过程](https://img-blog.csdnimg.cn/20210228205921773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODgzNjI3Mw==,size_16,color_FFFFFF,t_70#pic_center)
- **分段存储管理**：**按照程序自身逻辑关系划分为若干个段**，每个段有一个段名，每段从0开始编址。每个段在内存中占据连续空间，但各个段之间可以不相邻。与分页存储类似，操作系统在分段存储时为每个进程建立一张**段表**来保存各个段离散装入内存对应的段长、基址（与分页相似，段表项长度相同，可以通过段表计算段号，所以段号是隐含的不占存储空间）等信息。分段存储管理逻辑地址到物理地址的转换如下图：
![分段基本地址变化过程](https://img-blog.csdnimg.cn/20210301100533930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODgzNjI3Mw==,size_16,color_FFFFFF,t_70#pic_center)
可以看出分段存储中由于每个段的长度都不同，因此对比分页存储多了段内地址越界检查。
- **==分段与分页的对比==**：
> 1. **页**是**信息的物理单元**对用户不可见，**段**是**信息的逻辑单元**对用户可见。
> 2. **页**的**大小固定且由系统决定**，**段**的**长度不固定且决定于用户编写的程序**。
> 3. **分页**的**用户进程地址是一维的**（只需要一个记忆符），**分段**的**用户进程地址是二维的**（需要给出段名和段内地址）。
> 4. **分段更容易实现信息的共享和保护**（只能共享不属于临界资源的代码），当需要让内存中的某个片段共享给多个进程，只需要将各个进程的段表指向同一个段即可。
- **==加快分页过程==**：
> 1. 如何提高逻辑地址和物理地址的映射速度？(**快表**)\
> &emsp;&emsp;系统一旦访问了某一个页，就会在一段时间内稳定工作在这个页上。所以为了提高访问页表的速度，计算机配备了一组能容纳部分页表的**硬件寄存器**。当系统再次需要将地址转换时，先访问这组硬件寄存器（即，快表）。
> 2. 页表过大怎么解决？\
> &emsp;&emsp;**页表**存在的问题是，页表必须连续存放在过个连续的页框中，页表过大时离散存储失去了其本质意义，所以可以再建一级索引（**二级页表**）来让原页表连续页表项分组离散存储。

------
参考：《王道考研操作系统》
地址：https://www.bilibili.com/video/BV1YE411D7nH
